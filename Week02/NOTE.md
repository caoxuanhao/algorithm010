学习笔记

## 哈希表

Hash Table又称为散列表，在Java中，通过一个链表数组来实现该数据结构，每一个链表又叫做桶。

使用数组长度对元素对象的HashCode取模来确定该元素的下标索引。

Rehash，当表中位置达到填装因子(load factor，一般为0.75)标识的水位时，散列表会扩容。

哈希碰撞：不同关键码值对应的哈希值相同，一般是用一个链表存储相同哈希值的关键码值。

时间复杂度：`O(1)`

哈希碰撞较多情况下，哈希表的性能会有所下降

## 树

### 链表、树和图的关系

- 树是没有环的图。
- 链表是单叉的树。

### 树遍历

- 前序遍历(pre-order)：根--左--右
- 中序遍历(in-order)：左--根--右
- 后序遍历(post-order)：左--右--根

### 二叉搜索树

- 左子树所有结点值均小于根结点的值
- 右子树所有结点值均大于根结点的值
- 以此类推：左右子树也是二叉搜索树

> 中序遍历是升序的。
>
> 非叶子结点删除，一般用大于其的第一个结点替代其位置

## 堆

Heap：可以迅速找到一堆数中`最大`或`最小`值的数据结构

根结点

- 大根堆
- 小根堆

常见：

- 二叉堆（容易实现，但是效率仅达标）
- 斐波那契堆（性能好）
- 严格斐波那契堆（性能最好，但实现复杂）

### 二叉堆

性质

- 完全树
- 树中任意结点的值 >= 子结点的值

实现

- 通过数组实现
- 索引i的左孩子索引：(2*i + 1)
- 索引i的右孩子索引：(2*i + 2)
- 索引i的父结点索引：floor((i - 1) / 2)

插入

- 插到堆的尾部，依次向上调整整个堆结构（每次跟父结点对比，一直到根）HeapifyUp

  时间复杂度：O(logN)

删除

- 堆尾替换删除元素，依次从根向下调整整个堆结构（与较大孩子交换，直到堆尾）HeapifyDown

  时间复杂度：O(logN)

## 图

属性

- Graph(V, E)
- Vertex 点
  - 度：入度和出度
  - 点与点之间：连通与否
- Edge 边
  - 有向和无向
  - 权重

表示方法

- 邻接矩阵
- 邻接表

分类

- 无向无权（邻接矩阵对称）
- 无向有权（邻接矩阵对称）
- 有向无权
- 有向有权

常见算法

- DFS
- BFS

> 在实现遍历时，注意使用visitedSet判断环。